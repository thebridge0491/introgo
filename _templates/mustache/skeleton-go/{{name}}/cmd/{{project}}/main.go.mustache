package main

// single-line comment
/* multi-line comment: 
 * ... */

import ( "flag" ; "fmt" ; "os" ; "regexp" ; "io/ioutil" ; "encoding/json"
	log "github.com/alecthomas/log4go" ; "github.com/unknwon/goconfig"
	"github.com/BurntSushi/toml" ; "github.com/go-yaml/yaml"
	lib "{{repohost}}{{^repohost}}bitbucket.org{{/repohost}}/{{repoacct}}{{^repoacct}}imcomputer{{/repoacct}}/{{parent}}{{^parent}}introgo{{/parent}}/{{project}}{{^project}}introutil{{/project}}"
)

type OptsRecord struct {
	name string
}

func deserializeStr(dataBytes []byte, dataFmt string, err error, errPfx string) map[string]interface{} {
	blankMap := make(map[string]interface{})
	blankMap["fmt"] = dataFmt
	if nil != err {
		fmt.Fprintf(os.Stderr, "%s: %s\n", errPfx, err)
    	//os.Exit(1)
		return blankMap
	}
	if "yaml" == dataFmt || "json" == dataFmt {
		yaml.Unmarshal([]byte(dataBytes), &blankMap)
	} else if "toml" == dataFmt {
		toml.Unmarshal([]byte(dataBytes), &blankMap)
	} //else if "json" == dataFmt {
	//	json.Unmarshal([]byte(dataBytes), &blankMap)
	//}
	return blankMap
}

func run{{projectcap}}{{^projectcap}}Introutil{{/projectcap}}(name string) () {
	matchQuit, err := regexp.MatchString("(?i)^quit$", name)
	
	if nil != err {
        fmt.Fprintf(os.Stderr, "Regexp MatchString error\n")
        os.Exit(1)
    }
	if matchQuit { fmt.Printf("Good match: %s to %s\n", name, "\"^quit$\"")
	} else { fmt.Printf("Does not match: %s to %s\n", name, "\"^quit$\"") }
}

func parseCmdopts(opts *OptsRecord) {
	flag.StringVar(&opts.name, "u", opts.name, "user name")
	log.Info("parseCmdopts")
    flag.Parse()
	//fmt.Fprintln(os.Stderr, flag.Args())
}

func recoverMain() {
	if r := recover(); nil != r {
		fmt.Println("Recovered in main ---", r)
	}
}

// main - entry point (DocComment)
func main() {
	defer recoverMain()
	var rsrcPath string
	envRsrcPath, issetEnvRsrcPath := os.LookupEnv("RSRC_PATH")
	if issetEnvRsrcPath { rsrcPath = envRsrcPath
	} else { rsrcPath = "resources" }
	
	_, err := os.Stat(rsrcPath + "/log4go.xml")
	if os.IsNotExist(err) {
    	//panic(fmt.Sprintf("os.Stat file error: %s\n", err))
		fmt.Fprintf(os.Stderr, "os.Stat file error: %s\n", err)
    	//os.Exit(1)
    } else {
		log.LoadConfiguration(rsrcPath + "/log4go.xml")
	}
	
	opts := OptsRecord{name: "World"}
	
    parseCmdopts(&opts)
    
    var rowsArr = make([][]string, 0)
    iniCfg, err := goconfig.LoadConfigFile(rsrcPath + "/prac.conf")
    if nil != err {
    	fmt.Fprintf(os.Stderr, "goconfig.LoadConfigFile data error: %s\n", err)
    	//os.Exit(1)
    	rowsArr = append(rowsArr, []string{"????\n", "???", "???"})
    } else {
		rowsArr = append(rowsArr, []string{lib.IniCfgToStr(iniCfg), 
			iniCfg.MustValue("default", "domain"),
			iniCfg.MustValue("user1", "name")})
	}
    
    
    jsonStr, jsonErr := ioutil.ReadFile(rsrcPath + "/prac.json")
	tomlStr, tomlErr := ioutil.ReadFile(rsrcPath + "/prac.toml")
	yamlStr, yamlErr := ioutil.ReadFile(rsrcPath + "/prac.yaml")
	
	var jsonMap = deserializeStr(jsonStr, "json", jsonErr,
		"ioutil.ReadFile data error")
	var tomlMap = deserializeStr(tomlStr, "toml", tomlErr,
		"ioutil.ReadFile data error")
	var yamlMap = deserializeStr(yamlStr, "yaml", yamlErr,
		"ioutil.ReadFile data error")
    
    if nil != jsonErr {
    	rowsArr = append(rowsArr, []string{"????\n", "???", "???"})
	} else if nil != jsonMap["user1"] {
		rowsArr = append(rowsArr, []string{fmt.Sprintf("%s", jsonMap),
			fmt.Sprintf("%s", jsonMap["domain"]),
			//fmt.Sprintf("%s", jsonMap["user1"].(map[string]interface{})["name"]),
			fmt.Sprintf("%s", jsonMap["user1"].(map[interface{}]interface{})["name"]),
			})
	}
	if nil != tomlErr {
    	rowsArr = append(rowsArr, []string{"????\n", "???", "???"})
	} else if nil != tomlMap["user1"] {
		rowsArr = append(rowsArr, []string{fmt.Sprintf("%s", tomlMap),
			fmt.Sprintf("%s", tomlMap["domain"]),
			fmt.Sprintf("%s", tomlMap["user1"].(map[string]interface{})["name"])})
	}
	if nil != yamlErr {
    	rowsArr = append(rowsArr, []string{"????\n", "???", "???"})
	} else if nil != yamlMap["user1"] {
		rowsArr = append(rowsArr, []string{fmt.Sprintf("%s", yamlMap),
			fmt.Sprintf("%s", yamlMap["domain"]),
			fmt.Sprintf("%s", yamlMap["user1"].(map[interface{}]interface{})["name"])})
	}
	
    //sectList := iniCfg.GetSectionList()
    //fmt.Printf("%s\n", sectList)
    for _, row := range rowsArr {
		fmt.Printf("\nconfig: %s", row[0])
		fmt.Printf("\ndomain: %s", row[1])
		fmt.Printf("\nuser1Name: %s\n", row[2])
	}
    
    run{{projectcap}}{{^projectcap}}Introutil{{/projectcap}}(opts.name)
    
    log.Debug("exiting main()")
}
